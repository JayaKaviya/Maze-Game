<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Invisible Maze Challenge</title>
<style>
body {
  background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
  color: white;
  font-family: 'Segoe UI', Arial, sans-serif;
  text-align: center;
  padding: 20px;
  min-height: 100vh;
  margin: 0;
}

.container {
  max-width: 600px;
  margin: 0 auto;
}

h2 {
  font-size: 28px;
  margin-bottom: 10px;
  color: #fbbf24;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}

.instructions {
  background: rgba(30, 41, 59, 0.8);
  padding: 15px;
  border-radius: 10px;
  margin-bottom: 20px;
  border: 2px solid #334155;
}

.instructions p {
  margin: 8px 0;
  font-size: 14px;
}

.status {
  background: rgba(51, 65, 85, 0.9);
  padding: 12px;
  border-radius: 8px;
  margin-bottom: 15px;
  font-size: 16px;
  font-weight: bold;
}

.buttons {
  margin-bottom: 20px;
}

button {
  padding: 12px 24px;
  margin: 5px;
  cursor: pointer;
  border-radius: 8px;
  border: 2px solid #475569;
  background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
  color: white;
  font-size: 16px;
  font-weight: bold;
  transition: all 0.3s;
}

button:hover {
  background: linear-gradient(135deg, #334155 0%, #475569 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

button:active {
  transform: translateY(0);
}

table {
  margin: 20px auto;
  border-collapse: collapse;
  box-shadow: 0 8px 24px rgba(0,0,0,0.5);
}

td {
  width: 50px;
  height: 50px;
  border: 1px solid #475569;
  background: #f8fafc;
  text-align: center;
  vertical-align: middle;
  font-size: 28px;
  user-select: none;
  position: relative;
  transition: background 0.2s;
}

/* Mobile-friendly: smaller cells on small screens */
@media (max-width: 480px) {
  td {
    width: 40px;
    height: 40px;
    font-size: 24px;
  }
}

.player::after { 
  content: "üë§"; 
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.key::after { 
  content: "üîë"; 
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.door::after { 
  content: "üö™"; 
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.home::after { 
  content: "üè†"; 
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.player-home::before { 
  content: "üè†"; 
  position: absolute; 
  left: 8px;
  top: 50%;
  transform: translateY(-50%);
}

.player-home::after { 
  content: "üë§"; 
  position: absolute; 
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
}

.player-key::before { 
  content: "üîë"; 
  position: absolute; 
  left: 8px;
  top: 50%;
  transform: translateY(-50%);
}

.player-key::after { 
  content: "üë§"; 
  position: absolute; 
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
}

.hit { 
  background: #dc2626 !important;
  animation: shake 0.3s;
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

.win-message {
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  padding: 15px;
  border-radius: 10px;
  margin-top: 15px;
  font-size: 18px;
  font-weight: bold;
  animation: pulse 1s infinite;
}

.lose-message {
  background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
  padding: 15px;
  border-radius: 10px;
  margin-top: 15px;
  font-size: 18px;
  font-weight: bold;
  animation: pulse 1s infinite;
}

.timer-warning {
  color: #fbbf24 !important;
  animation: blink 1s infinite;
}

.timer-critical {
  color: #dc2626 !important;
  animation: blink 0.5s infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0.4; }
}

.solution-path {
  background: rgba(34, 197, 94, 0.6) !important;
  border: 2px solid #22c55e !important;
}

.solution-key {
  background: rgba(251, 191, 36, 0.6) !important;
  border: 2px solid #fbbf24 !important;
}

.solution-text {
  background: rgba(59, 130, 246, 0.9);
  padding: 10px;
  border-radius: 8px;
  margin-top: 10px;
  font-size: 14px;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

/* On-screen controls */
.controls {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 20px auto;
  max-width: 250px;
}

.dpad {
  display: grid;
  grid-template-columns: 70px 70px 70px;
  grid-template-rows: 70px 70px 70px;
  gap: 5px;
}

.arrow-btn {
  width: 70px;
  height: 70px;
  border: 3px solid #475569;
  background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
  color: white;
  font-size: 32px;
  cursor: pointer;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
  transition: all 0.1s;
  touch-action: manipulation;
}

.arrow-btn:active {
  background: linear-gradient(135deg, #334155 0%, #475569 100%);
  transform: scale(0.95);
}

.arrow-btn:hover {
  background: linear-gradient(135deg, #334155 0%, #475569 100%);
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

#up-btn {
  grid-column: 2;
  grid-row: 1;
}

#left-btn {
  grid-column: 1;
  grid-row: 2;
}

#down-btn {
  grid-column: 2;
  grid-row: 3;
}

#right-btn {
  grid-column: 3;
  grid-row: 2;
}

.spacer {
  grid-column: 2;
  grid-row: 2;
}

@media (max-width: 480px) {
  .dpad {
    grid-template-columns: 60px 60px 60px;
    grid-template-rows: 60px 60px 60px;
    gap: 4px;
  }
  
  .arrow-btn {
    width: 60px;
    height: 60px;
    font-size: 28px;
  }
}
</style>
</head>
<body>
<div class="container">
  <h2>üîê Invisible Maze Challenge</h2>
  
  <div class="instructions">
    <p><strong>üéØ Mission:</strong> Collect 2 keys (üîë) and reach home (üè†)</p>
    <p><strong>‚ö†Ô∏è Rules:</strong> The maze is invisible! Hit a wall = restart from beginning</p>
    <p><strong>üéÆ Controls:</strong> Use Arrow Keys / On-screen buttons / Swipe</p>
    <p><strong>üí° Tip:</strong> You can walk over home without all keys - just keep exploring!</p>
  </div>

  <div class="status" id="status">
    ‚è±Ô∏è Time: <span id="timer">4:00</span> | Keys: <span id="keyCount">0</span> / 2 | Attempts: <span id="attempts">0</span>
  </div>

  <div class="buttons">
    <button onclick="startGame(5)">Easy (5√ó5)</button>
    <button onclick="startGame(6)">Medium (6√ó6)</button>
    <button onclick="startGame(7)">Hard (7√ó7)</button>
    <button id="solutionBtn" onclick="toggleSolution()" style="background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); display: none;">Show Solution</button>
  </div>

  <div id="maze"></div>
  
  <!-- On-screen D-pad controls -->
  <div class="controls">
    <div class="dpad">
      <button class="arrow-btn" id="up-btn">‚Üë</button>
      <button class="arrow-btn" id="left-btn">‚Üê</button>
      <div class="spacer"></div>
      <button class="arrow-btn" id="right-btn">‚Üí</button>
      <button class="arrow-btn" id="down-btn">‚Üì</button>
    </div>
  </div>
  
  <div id="winMessage"></div>
</div>

<script>
let size, player, start;
let keysCollected = 0;
let hitCell = null;
let activeKeys = [];
let gameWon = false;
let maze = [];
let door, keys = [];
let attempts = 0;
let timeLeft = 240;
let timerInterval = null;
let gameActive = false;
let showingSolution = false;
let solutionPath = [];

const DIRS = [[-1,0], [1,0], [0,-1], [0,1]];

// Touch/Swipe support
let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;

// Start new game
function startGame(n) {
  if (showingSolution) {
    showingSolution = false;
    solutionPath = [];
    timeLeft = 240;
    gameActive = true;
    attempts = 0;
    
    document.getElementById("solutionBtn").style.display = "none";
    document.getElementById("solutionBtn").textContent = "Show Solution";
    document.getElementById("winMessage").innerHTML = "";
    
    if (timerInterval) clearInterval(timerInterval);
    
    resetGame();
    render();
    updateStatus();
    startTimer();
    return;
  }
  
  size = n;
  attempts = 0;
  timeLeft = 240;
  gameActive = true;
  showingSolution = false;
  solutionPath = [];
  
  document.getElementById("solutionBtn").style.display = "none";
  document.getElementById("winMessage").innerHTML = "";
  
  if (timerInterval) clearInterval(timerInterval);
  
  generateHardMaze();
  resetGame();
  render();
  updateStatus();
  startTimer();
}

// Generate hard maze
function generateHardMaze() {
  maze = Array.from({length: size}, () => Array(size).fill(0));
  
  const stack = [];
  const visited = Array.from({length: size}, () => Array(size).fill(false));

  let r = 0, c = 0;
  maze[r][c] = 1;
  visited[r][c] = true;
  stack.push([r, c]);

  while (stack.length > 0) {
    [r, c] = stack[stack.length - 1];
    
    const neighbors = [];
    for (const [dr, dc] of DIRS) {
      const nr = r + dr * 2;
      const nc = c + dc * 2;
      if (nr >= 0 && nr < size && nc >= 0 && nc < size && !visited[nr][nc]) {
        neighbors.push([nr, nc, dr, dc]);
      }
    }

    if (neighbors.length > 0) {
      const [nr, nc, dr, dc] = neighbors[Math.floor(Math.random() * neighbors.length)];
      maze[r + dr][c + dc] = 1;
      maze[nr][nc] = 1;
      visited[nr][nc] = true;
      stack.push([nr, nc]);
    } else {
      stack.pop();
    }
  }

  maze[size - 1][size - 1] = 1;
  door = [size - 1, size - 1];
  
  // Block straight paths
  for (let i = 1; i < size - 1; i++) {
    for (let j = 1; j < size - 1; j++) {
      if (maze[i][j] === 1 && !(i === 0 && j === 0) && !(i === size-1 && j === size-1)) {
        let straightH = 0, straightV = 0;
        
        for (let k = j - 1; k >= 0 && maze[i][k] === 1; k--) straightH++;
        for (let k = j + 1; k < size && maze[i][k] === 1; k++) straightH++;
        for (let k = i - 1; k >= 0 && maze[k][j] === 1; k--) straightV++;
        for (let k = i + 1; k < size && maze[k][j] === 1; k++) straightV++;
        
        if ((straightH >= 2 || straightV >= 2) && Math.random() > 0.3) {
          const tempMaze = maze.map(row => [...row]);
          tempMaze[i][j] = 0;
          if (isConnected(tempMaze)) maze[i][j] = 0;
        }
      }
    }
  }
  
  ensureConnectivity();
  
  const reachable = findAllReachable([0, 0]);
  const validPositions = reachable.filter(([r, c]) => 
    !(r === 0 && c === 0) && !(r === size - 1 && c === size - 1)
  );
  
  if (validPositions.length < 2) {
    maze[0][1] = 1;
    maze[1][0] = 1;
    maze[1][1] = 1;
    keys = [[0, 1], [1, 0]];
  } else {
    keys = findOptimalKeyPlacement(validPositions);
  }
  
  ensurePathExists([0, 0], keys[0]);
  ensurePathExists(keys[0], keys[1]);
  ensurePathExists(keys[1], door);
}

function isConnected(testMaze) {
  const visited = Array.from({length: size}, () => Array(size).fill(false));
  const queue = [[0, 0]];
  visited[0][0] = true;
  
  while (queue.length > 0) {
    const [r, c] = queue.shift();
    for (const [dr, dc] of DIRS) {
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < size && nc >= 0 && nc < size && 
          testMaze[nr][nc] === 1 && !visited[nr][nc]) {
        visited[nr][nc] = true;
        queue.push([nr, nc]);
      }
    }
  }
  return visited[size - 1][size - 1];
}

function ensureConnectivity() {
  if (!isConnected(maze)) {
    const path = findShortestPath([0, 0], [size - 1, size - 1], true);
    path.forEach(([r, c]) => maze[r][c] = 1);
  }
}

function findAllReachable(start) {
  const reachable = [];
  const queue = [start];
  const visited = Array.from({length: size}, () => Array(size).fill(false));
  visited[start[0]][start[1]] = true;
  
  while (queue.length > 0) {
    const [r, c] = queue.shift();
    reachable.push([r, c]);
    for (const [dr, dc] of DIRS) {
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < size && nc >= 0 && nc < size && 
          maze[nr][nc] === 1 && !visited[nr][nc]) {
        visited[nr][nc] = true;
        queue.push([nr, nc]);
      }
    }
  }
  return reachable;
}

function findShortestPath(start, end, carve = false) {
  const queue = [[start, [start]]];
  const visited = new Set([`${start[0]},${start[1]}`]);
  
  while (queue.length > 0) {
    const [[r, c], path] = queue.shift();
    if (r === end[0] && c === end[1]) return path;
    
    for (const [dr, dc] of DIRS) {
      const nr = r + dr, nc = c + dc;
      const key = `${nr},${nc}`;
      if (nr >= 0 && nr < size && nc >= 0 && nc < size && !visited.has(key)) {
        if (maze[nr][nc] === 1 || carve) {
          visited.add(key);
          queue.push([[nr, nc], [...path, [nr, nc]]]);
        }
      }
    }
  }
  return [];
}

function ensurePathExists(start, end) {
  const existingPath = findShortestPath(start, end, false);
  if (existingPath.length === 0) {
    const path = findShortestPath(start, end, true);
    path.forEach(([r, c]) => maze[r][c] = 1);
  }
}

function findOptimalKeyPlacement(validPositions) {
  let bestKeys = [validPositions[0], validPositions[Math.min(1, validPositions.length - 1)]];
  let maxComplexity = 0;
  
  const numAttempts = Math.min(50, validPositions.length * (validPositions.length - 1) / 2);
  
  for (let attempt = 0; attempt < numAttempts; attempt++) {
    const idx1 = Math.floor(Math.random() * validPositions.length);
    const idx2 = Math.floor(Math.random() * validPositions.length);
    if (idx1 === idx2) continue;
    
    const key1 = validPositions[idx1];
    const key2 = validPositions[idx2];
    
    const pathToKey1 = findShortestPath([0, 0], key1);
    const pathToKey2 = findShortestPath(key1, key2);
    const pathToHome = findShortestPath(key2, door);
    
    if (pathToKey1.length > 0 && pathToKey2.length > 0 && pathToHome.length > 0) {
      const totalLength = pathToKey1.length + pathToKey2.length + pathToHome.length;
      const manhattanDist = Math.abs(key1[0] - key2[0]) + Math.abs(key1[1] - key2[1]);
      const complexity = totalLength + manhattanDist;
      const notSameRowCol = (key1[0] !== key2[0] && key1[1] !== key2[1]) ? 20 : 0;
      
      if (complexity + notSameRowCol > maxComplexity) {
        maxComplexity = complexity + notSameRowCol;
        bestKeys = [key1, key2];
      }
    }
  }
  return bestKeys;
}

function resetGame() {
  player = [0, 0];
  activeKeys = keys.map(k => [...k]);
  keysCollected = 0;
  hitCell = null;
  gameWon = false;
  document.getElementById("winMessage").innerHTML = "";
}

// Keyboard controls
document.addEventListener("keydown", e => {
  if (gameWon || !gameActive) return;
  const map = {ArrowUp: [-1, 0], ArrowDown: [1, 0], ArrowLeft: [0, -1], ArrowRight: [0, 1]};
  if (map[e.key]) {
    e.preventDefault();
    move(...map[e.key]);
  }
});

// Touch/Swipe controls
document.addEventListener('touchstart', e => {
  touchStartX = e.changedTouches[0].screenX;
  touchStartY = e.changedTouches[0].screenY;
}, false);

document.addEventListener('touchend', e => {
  if (gameWon || !gameActive) return;
  
  touchEndX = e.changedTouches[0].screenX;
  touchEndY = e.changedTouches[0].screenY;
  handleSwipe();
}, false);

function handleSwipe() {
  const deltaX = touchEndX - touchStartX;
  const deltaY = touchEndY - touchStartY;
  const minSwipeDistance = 30; // Minimum distance for a swipe
  
  // Determine if it's a horizontal or vertical swipe
  if (Math.abs(deltaX) > Math.abs(deltaY)) {
    // Horizontal swipe
    if (Math.abs(deltaX) > minSwipeDistance) {
      if (deltaX > 0) {
        move(0, 1); // Right
      } else {
        move(0, -1); // Left
      }
    }
  } else {
    // Vertical swipe
    if (Math.abs(deltaY) > minSwipeDistance) {
      if (deltaY > 0) {
        move(1, 0); // Down
      } else {
        move(-1, 0); // Up
      }
    }
  }
}

// On-screen button controls
document.getElementById('up-btn').addEventListener('click', () => {
  if (!gameWon && gameActive) move(-1, 0);
});

document.getElementById('down-btn').addEventListener('click', () => {
  if (!gameWon && gameActive) move(1, 0);
});

document.getElementById('left-btn').addEventListener('click', () => {
  if (!gameWon && gameActive) move(0, -1);
});

document.getElementById('right-btn').addEventListener('click', () => {
  if (!gameWon && gameActive) move(0, 1);
});

// Prevent button click from triggering touch events
document.querySelectorAll('.arrow-btn').forEach(btn => {
  btn.addEventListener('touchstart', (e) => {
    e.stopPropagation();
  });
  btn.addEventListener('touchend', (e) => {
    e.stopPropagation();
  });
});

function move(dr, dc) {
  const [r, c] = player;
  const nr = r + dr, nc = c + dc;
  
  if (nr < 0 || nc < 0 || nr >= size || nc >= size || maze[nr][nc] === 0) {
    hitCell = [nr >= 0 && nr < size && nc >= 0 && nc < size ? nr : r, 
               nr >= 0 && nr < size && nc >= 0 && nc < size ? nc : c];
    attempts++;
    render();
    updateStatus();
    setTimeout(() => {
      hitCell = null;
      resetGame();
      render();
      updateStatus();
    }, 400);
    return;
  }
  
  player = [nr, nc];
  checkCollision();
  render();
  updateStatus();
}

function checkCollision() {
  // Check for key collection
  activeKeys.forEach((k, i) => {
    if (k && player[0] === k[0] && player[1] === k[1]) {
      activeKeys[i] = null;
      keysCollected++;
    }
  });

  // Only win if at home AND have both keys
  if (player[0] === door[0] && player[1] === door[1] && keysCollected === 2) {
    gameWon = true;
    gameActive = false;
    clearInterval(timerInterval);
    
    const minutes = Math.floor((240 - timeLeft) / 60);
    const seconds = (240 - timeLeft) % 60;
    const timeUsed = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    document.getElementById("winMessage").innerHTML = 
      `<div class="win-message">üéâ Victory! You completed the ${size}√ó${size} maze in ${timeUsed} (${attempts} attempts)!</div>`;
    
    document.getElementById("solutionBtn").style.display = "inline-block";
    document.getElementById("solutionBtn").textContent = "View Solution Path";
    
    setTimeout(() => {
      if (!showingSolution) startGame(size);
    }, 4000);
  }
  // If at home but don't have both keys, just continue - no reset!
}

function render() {
  let html = "<table>";
  for (let r = 0; r < size; r++) {
    html += "<tr>";
    for (let c = 0; c < size; c++) {
      let cls = [];
      
      if (showingSolution) {
        if (solutionPath.some(([pr, pc]) => pr === r && pc === c)) cls.push("solution-path");
        if (keys.some(k => k && k[0] === r && k[1] === c)) cls.push("solution-key");
      }
      
      if (player[0] === r && player[1] === c) {
        if (gameWon && r === door[0] && c === door[1]) {
          cls.push("player-home");
        } else {
          cls.push("player");
        }
      }
      
      if (!showingSolution) {
        activeKeys.forEach(k => {
          if (k && k[0] === r && k[1] === c) {
            if (player[0] === r && player[1] === c) {
              cls = ["player-key"];
            } else {
              cls.push("key");
            }
          }
        });
      }
      
      if (r === door[0] && c === door[1] && !cls.includes("player-home") && !cls.includes("player")) {
        if (keysCollected === 2 || showingSolution) cls.push("home");
        else cls.push("door");
      }
      
      if (hitCell && hitCell[0] === r && hitCell[1] === c) cls = ["hit"];
      
      html += `<td class="${cls.join(" ")}"></td>`;
    }
    html += "</tr>";
  }
  html += "</table>";
  document.getElementById("maze").innerHTML = html;
}

function updateStatus() {
  document.getElementById("keyCount").textContent = keysCollected;
  document.getElementById("attempts").textContent = attempts;
  updateTimerDisplay();
}

function startTimer() {
  timerInterval = setInterval(() => {
    if (!gameActive) {
      clearInterval(timerInterval);
      return;
    }
    timeLeft--;
    updateTimerDisplay();
    if (timeLeft <= 0) gameOver();
  }, 1000);
}

function updateTimerDisplay() {
  const minutes = Math.floor(timeLeft / 60);
  const seconds = timeLeft % 60;
  const timerDisplay = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  const timerElement = document.getElementById("timer");
  
  timerElement.textContent = timerDisplay;
  timerElement.classList.remove('timer-warning', 'timer-critical');
  
  if (timeLeft <= 30) timerElement.classList.add('timer-critical');
  else if (timeLeft <= 60) timerElement.classList.add('timer-warning');
  
  if (timeLeft <= 0) document.getElementById("solutionBtn").style.display = "inline-block";
}

function gameOver() {
  gameActive = false;
  gameWon = false;
  clearInterval(timerInterval);
  
  document.getElementById("winMessage").innerHTML = 
    `<div class="lose-message">‚è∞ TIME'S UP! You're out! Try again?</div>`;
  document.getElementById("solutionBtn").style.display = "inline-block";
  
  setTimeout(() => {
    if (!showingSolution) {
      document.getElementById("winMessage").innerHTML = "";
      startGame(size);
    }
  }, 3000);
}

function toggleSolution() {
  if (!showingSolution) {
    showSolution();
    document.getElementById("solutionBtn").textContent = "Hide Solution";
  } else {
    showingSolution = false;
    solutionPath = [];
    render();
    document.getElementById("solutionBtn").textContent = "Show Solution";
    document.getElementById("winMessage").innerHTML = "";
  }
}

function showSolution() {
  showingSolution = true;
  solutionPath = [];
  
  const pathToKey1Direct = findShortestPath([0, 0], keys[0]);
  const pathToKey2Direct = findShortestPath([0, 0], keys[1]);
  
  let firstKey, secondKey;
  
  const path1_2 = findShortestPath(keys[0], keys[1]);
  const path2_1 = findShortestPath(keys[1], keys[0]);
  
  if (pathToKey1Direct.length > 0 && path1_2.length > 0) {
    const pathToHome1 = findShortestPath(keys[1], door);
    if (pathToHome1.length > 0) {
      firstKey = keys[0];
      secondKey = keys[1];
      solutionPath = [...pathToKey1Direct, ...path1_2.slice(1), ...pathToHome1.slice(1)];
    }
  }
  
  if (solutionPath.length === 0 && pathToKey2Direct.length > 0 && path2_1.length > 0) {
    const pathToHome2 = findShortestPath(keys[0], door);
    if (pathToHome2.length > 0) {
      firstKey = keys[1];
      secondKey = keys[0];
      solutionPath = [...pathToKey2Direct, ...path2_1.slice(1), ...pathToHome2.slice(1)];
    }
  }
  
  if (solutionPath.length === 0) {
    solutionPath = [
      ...(pathToKey1Direct.length > 0 ? pathToKey1Direct : pathToKey2Direct),
      ...(path1_2.length > 0 ? path1_2.slice(1) : path2_1.slice(1))
    ];
  }
  
  render();
  
  const pathLength = solutionPath.length;
  const keyOrder = firstKey ? 
    `üìç Path: Start (0,0) ‚Üí üîë (${firstKey[0]},${firstKey[1]}) ‚Üí üîë (${secondKey[0]},${secondKey[1]}) ‚Üí üè† (${size-1},${size-1})` :
    `Follow the green path to collect both keys and reach home`;
  
  document.getElementById("winMessage").innerHTML = 
    `<div class="solution-text">
      ‚ú® <strong>SOLUTION REVEALED</strong> ‚ú®<br>
      üü¢ Green path = Correct route (${pathLength} steps)<br>
      üü° Yellow highlight = Key locations<br>
      ${keyOrder}<br>
      <strong>Click any difficulty button to try the SAME puzzle again!</strong>
    </div>`;
}

startGame(6);
</script>
</body>
</html>