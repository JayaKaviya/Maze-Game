<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Invisible Maze Challenge</title>
<style>
body {
  background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
  color: white;
  font-family: 'Segoe UI', Arial, sans-serif;
  text-align: center;
  padding: 20px;
  min-height: 100vh;
  margin: 0;
}

.container {
  max-width: 600px;
  margin: 0 auto;
}

h2 {
  font-size: 28px;
  margin-bottom: 10px;
  color: #fbbf24;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}

.instructions {
  background: rgba(30, 41, 59, 0.8);
  padding: 15px;
  border-radius: 10px;
  margin-bottom: 20px;
  border: 2px solid #334155;
}

.instructions p {
  margin: 8px 0;
  font-size: 14px;
}

.status {
  background: rgba(51, 65, 85, 0.9);
  padding: 12px;
  border-radius: 8px;
  margin-bottom: 15px;
  font-size: 16px;
  font-weight: bold;
}

.buttons {
  margin-bottom: 20px;
}

button {
  padding: 12px 24px;
  margin: 5px;
  cursor: pointer;
  border-radius: 8px;
  border: 2px solid #475569;
  background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
  color: white;
  font-size: 16px;
  font-weight: bold;
  transition: all 0.3s;
}

button:hover {
  background: linear-gradient(135deg, #334155 0%, #475569 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

button:active {
  transform: translateY(0);
}

table {
  margin: 20px auto;
  border-collapse: collapse;
  box-shadow: 0 8px 24px rgba(0,0,0,0.5);
}

td {
  width: 50px;
  height: 50px;
  border: 1px solid #475569;
  background: #f8fafc;
  text-align: center;
  vertical-align: middle;
  font-size: 28px;
  user-select: none;
  position: relative;
  transition: background 0.2s;
}

.player::after { 
  content: "üë§"; 
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.key::after { 
  content: "üîë"; 
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.door::after { 
  content: "üö™"; 
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.home::after { 
  content: "üè†"; 
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.player-home::before { 
  content: "üè†"; 
  position: absolute; 
  left: 8px;
  top: 50%;
  transform: translateY(-50%);
}

.player-home::after { 
  content: "üë§"; 
  position: absolute; 
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
}

.hit { 
  background: #dc2626 !important;
  animation: shake 0.3s;
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

.win-message {
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  padding: 15px;
  border-radius: 10px;
  margin-top: 15px;
  font-size: 18px;
  font-weight: bold;
  animation: pulse 1s infinite;
}

.lose-message {
  background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
  padding: 15px;
  border-radius: 10px;
  margin-top: 15px;
  font-size: 18px;
  font-weight: bold;
  animation: pulse 1s infinite;
}

.timer-warning {
  color: #fbbf24 !important;
  animation: blink 1s infinite;
}

.timer-critical {
  color: #dc2626 !important;
  animation: blink 0.5s infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0.4; }
}

.solution-path {
  background: rgba(34, 197, 94, 0.6) !important;
  border: 2px solid #22c55e !important;
}

.solution-key {
  background: rgba(251, 191, 36, 0.6) !important;
  border: 2px solid #fbbf24 !important;
}

.solution-text {
  background: rgba(59, 130, 246, 0.9);
  padding: 10px;
  border-radius: 8px;
  margin-top: 10px;
  font-size: 14px;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}
</style>
</head>
<body>
<div class="container">
  <h2>üîê Invisible Maze Challenge</h2>
  
  <div class="instructions">
    <p><strong>üéØ Mission:</strong> Collect 2 keys (üîë) and reach home (üè†)</p>
    <p><strong>‚ö†Ô∏è Rules:</strong> The maze is invisible! Hit a wall = restart from beginning</p>
    <p><strong>üéÆ Controls:</strong> Use Arrow Keys (‚Üë ‚Üì ‚Üê ‚Üí) to navigate</p>
  </div>

  <div class="status" id="status">
    ‚è±Ô∏è Time: <span id="timer">4:00</span> | Keys: <span id="keyCount">0</span> / 2 | Attempts: <span id="attempts">0</span>
  </div>

  <div class="buttons">
    <button onclick="startGame(5)">Easy (5√ó5)</button>
    <button onclick="startGame(6)">Medium (6√ó6)</button>
    <button onclick="startGame(7)">Hard (7√ó7)</button>
    <button id="solutionBtn" onclick="showSolution()" style="background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); display: none;">Show Solution</button>
  </div>

  <div id="maze"></div>
  <div id="winMessage"></div>
</div>

<script>
let size, player, start;
let keysCollected = 0;
let hitCell = null;
let activeKeys = [];
let gameWon = false;
let maze = []; // 0=wall, 1=path
let door, keys = [];
let attempts = 0;
let timeLeft = 240; // 4 minutes in seconds
let timerInterval = null;
let gameActive = false;
let showingSolution = false;
let solutionPath = [];

const DIRS = [[-1,0], [1,0], [0,-1], [0,1]];

// Start new game
function startGame(n) {
  size = n;
  attempts = 0;
  timeLeft = 240; // Reset to 4 minutes
  gameActive = true;
  showingSolution = false;
  solutionPath = [];
  
  // Hide solution button initially
  document.getElementById("solutionBtn").style.display = "none";
  
  // Clear existing timer
  if (timerInterval) {
    clearInterval(timerInterval);
  }
  
  generateHardMaze();
  resetGame();
  render();
  updateStatus();
  startTimer();
}

// Generate EXTREMELY HARD maze using advanced algorithms
function generateHardMaze() {
  // Initialize all cells as walls
  maze = Array.from({length: size}, () => Array(size).fill(0));
  
  // STEP 1: Generate base maze using recursive backtracking
  const stack = [];
  const visited = Array.from({length: size}, () => Array(size).fill(false));

  let r = 0, c = 0;
  maze[r][c] = 1;
  visited[r][c] = true;
  stack.push([r, c]);

  while (stack.length > 0) {
    [r, c] = stack[stack.length - 1];
    
    const neighbors = [];
    for (const [dr, dc] of DIRS) {
      const nr = r + dr * 2;
      const nc = c + dc * 2;
      if (nr >= 0 && nr < size && nc >= 0 && nc < size && !visited[nr][nc]) {
        neighbors.push([nr, nc, dr, dc]);
      }
    }

    if (neighbors.length > 0) {
      const [nr, nc, dr, dc] = neighbors[Math.floor(Math.random() * neighbors.length)];
      maze[r + dr][c + dc] = 1;
      maze[nr][nc] = 1;
      visited[nr][nc] = true;
      stack.push([nr, nc]);
    } else {
      stack.pop();
    }
  }

  maze[size - 1][size - 1] = 1;
  door = [size - 1, size - 1];
  
  // STEP 2: AGGRESSIVELY remove straight paths - this is the key!
  // Remove cells that allow straight horizontal or vertical movement
  for (let i = 1; i < size - 1; i++) {
    for (let j = 1; j < size - 1; j++) {
      if (maze[i][j] === 1 && !(i === 0 && j === 0) && !(i === size-1 && j === size-1)) {
        // Check if this creates a long straight path
        let straightHorizontal = 0;
        let straightVertical = 0;
        
        // Count consecutive horizontal cells
        for (let k = j - 1; k >= 0 && maze[i][k] === 1; k--) straightHorizontal++;
        for (let k = j + 1; k < size && maze[i][k] === 1; k++) straightHorizontal++;
        
        // Count consecutive vertical cells
        for (let k = i - 1; k >= 0 && maze[k][j] === 1; k--) straightVertical++;
        for (let k = i + 1; k < size && maze[k][j] === 1; k++) straightVertical++;
        
        // If there's a straight path of 3+ cells, remove this cell (70% chance)
        if ((straightHorizontal >= 2 || straightVertical >= 2) && Math.random() > 0.3) {
          // Check if removing won't disconnect the maze
          const tempMaze = maze.map(row => [...row]);
          tempMaze[i][j] = 0;
          
          if (isConnected(tempMaze)) {
            maze[i][j] = 0;
          }
        }
      }
    }
  }
  
  // STEP 3: Add strategic blocking walls in rows/columns
  // For each row and column, add random blocking walls
  for (let i = 1; i < size - 1; i++) {
    // Block some cells in this row
    const rowCells = [];
    for (let j = 1; j < size - 1; j++) {
      if (maze[i][j] === 1) rowCells.push(j);
    }
    
    // Block 30-50% of path cells in this row
    const numToBlock = Math.floor(rowCells.length * (0.3 + Math.random() * 0.2));
    for (let b = 0; b < numToBlock; b++) {
      const idx = Math.floor(Math.random() * rowCells.length);
      const colToBlock = rowCells.splice(idx, 1)[0];
      
      const tempMaze = maze.map(row => [...row]);
      tempMaze[i][colToBlock] = 0;
      
      if (isConnected(tempMaze)) {
        maze[i][colToBlock] = 0;
      }
    }
  }
  
  // Same for columns
  for (let j = 1; j < size - 1; j++) {
    const colCells = [];
    for (let i = 1; i < size - 1; i++) {
      if (maze[i][j] === 1) colCells.push(i);
    }
    
    const numToBlock = Math.floor(colCells.length * (0.3 + Math.random() * 0.2));
    for (let b = 0; b < numToBlock; b++) {
      const idx = Math.floor(Math.random() * colCells.length);
      const rowToBlock = colCells.splice(idx, 1)[0];
      
      const tempMaze = maze.map(row => [...row]);
      tempMaze[rowToBlock][j] = 0;
      
      if (isConnected(tempMaze)) {
        maze[rowToBlock][j] = 0;
      }
    }
  }
  
  // STEP 4: Ensure critical paths exist and reconnect if needed
  ensureConnectivity();
  
  // STEP 5: Place keys using dynamic programming
  // Find all reachable cells and calculate minimum path distances
  const reachable = findAllReachable([0, 0]);
  const validPositions = reachable.filter(([r, c]) => 
    !(r === 0 && c === 0) && !(r === size - 1 && c === size - 1)
  );
  
  if (validPositions.length < 2) {
    // Fallback - ensure some paths exist
    maze[0][1] = 1;
    maze[1][0] = 1;
    maze[1][1] = 1;
    keys = [[0, 1], [1, 0]];
  } else {
    // Use dynamic programming to find optimal key placement
    // that maximizes path complexity
    keys = findOptimalKeyPlacement(validPositions);
  }
  
  // Final verification
  ensurePathExists([0, 0], keys[0]);
  ensurePathExists(keys[0], keys[1]);
  ensurePathExists(keys[1], door);
}

// Check if maze is still connected using BFS
function isConnected(testMaze) {
  const visited = Array.from({length: size}, () => Array(size).fill(false));
  const queue = [[0, 0]];
  visited[0][0] = true;
  let pathCount = 1;
  
  while (queue.length > 0) {
    const [r, c] = queue.shift();
    
    for (const [dr, dc] of DIRS) {
      const nr = r + dr;
      const nc = c + dc;
      if (nr >= 0 && nr < size && nc >= 0 && nc < size && 
          testMaze[nr][nc] === 1 && !visited[nr][nc]) {
        visited[nr][nc] = true;
        queue.push([nr, nc]);
        pathCount++;
      }
    }
  }
  
  // Check if home is reachable
  return visited[size - 1][size - 1];
}

// Ensure start and end are connected
function ensureConnectivity() {
  if (!isConnected(maze)) {
    // Carve minimal path from start to end
    const path = findShortestPath([0, 0], [size - 1, size - 1], true);
    path.forEach(([r, c]) => maze[r][c] = 1);
  }
}

// Find all reachable cells from a starting position
function findAllReachable(start) {
  const reachable = [];
  const queue = [start];
  const visited = Array.from({length: size}, () => Array(size).fill(false));
  visited[start[0]][start[1]] = true;
  
  while (queue.length > 0) {
    const [r, c] = queue.shift();
    reachable.push([r, c]);
    
    for (const [dr, dc] of DIRS) {
      const nr = r + dr;
      const nc = c + dc;
      if (nr >= 0 && nr < size && nc >= 0 && nc < size && 
          maze[nr][nc] === 1 && !visited[nr][nc]) {
        visited[nr][nc] = true;
        queue.push([nr, nc]);
      }
    }
  }
  
  return reachable;
}

// Find shortest path (can carve through walls if carve=true)
function findShortestPath(start, end, carve = false) {
  const queue = [[start, [start]]];
  const visited = new Set([`${start[0]},${start[1]}`]);
  
  while (queue.length > 0) {
    const [[r, c], path] = queue.shift();
    
    if (r === end[0] && c === end[1]) {
      return path;
    }
    
    for (const [dr, dc] of DIRS) {
      const nr = r + dr;
      const nc = c + dc;
      const key = `${nr},${nc}`;
      
      if (nr >= 0 && nr < size && nc >= 0 && nc < size && !visited.has(key)) {
        if (maze[nr][nc] === 1 || carve) {
          visited.add(key);
          queue.push([[nr, nc], [...path, [nr, nc]]]);
        }
      }
    }
  }
  
  return [];
}

// Ensure a path exists between two points
function ensurePathExists(start, end) {
  const existingPath = findShortestPath(start, end, false);
  if (existingPath.length === 0) {
    // Carve a winding path
    const path = findShortestPath(start, end, true);
    path.forEach(([r, c]) => maze[r][c] = 1);
  }
}

// Dynamic Programming: Find optimal key placement that maximizes path difficulty
function findOptimalKeyPlacement(validPositions) {
  let bestKeys = [validPositions[0], validPositions[1]];
  let maxComplexity = 0;
  
  // Try multiple random combinations and pick the one with longest total path
  const numAttempts = Math.min(50, validPositions.length * (validPositions.length - 1) / 2);
  
  for (let attempt = 0; attempt < numAttempts; attempt++) {
    const idx1 = Math.floor(Math.random() * validPositions.length);
    const idx2 = Math.floor(Math.random() * validPositions.length);
    
    if (idx1 === idx2) continue;
    
    const key1 = validPositions[idx1];
    const key2 = validPositions[idx2];
    
    // Calculate path complexity: total Manhattan distance + path length
    const pathToKey1 = findShortestPath([0, 0], key1);
    const pathToKey2 = findShortestPath(key1, key2);
    const pathToHome = findShortestPath(key2, door);
    
    if (pathToKey1.length > 0 && pathToKey2.length > 0 && pathToHome.length > 0) {
      const totalLength = pathToKey1.length + pathToKey2.length + pathToHome.length;
      const manhattanDist = Math.abs(key1[0] - key2[0]) + Math.abs(key1[1] - key2[1]);
      const complexity = totalLength + manhattanDist;
      
      // Prefer keys that are NOT in same row or column (adds bonus)
      const notSameRowCol = (key1[0] !== key2[0] && key1[1] !== key2[1]) ? 20 : 0;
      
      if (complexity + notSameRowCol > maxComplexity) {
        maxComplexity = complexity + notSameRowCol;
        bestKeys = [key1, key2];
      }
    }
  }
  
  return bestKeys;
}

// Reset player position and keys after hitting wall
function resetGame() {
  player = [0, 0];
  activeKeys = keys.map(k => [...k]);
  keysCollected = 0;
  hitCell = null;
  gameWon = false;
  document.getElementById("winMessage").innerHTML = "";
}

// Handle keyboard input
document.addEventListener("keydown", e => {
  if (gameWon || !gameActive) return;
  
  const map = {
    ArrowUp: [-1, 0],
    ArrowDown: [1, 0],
    ArrowLeft: [0, -1],
    ArrowRight: [0, 1]
  };
  
  if (map[e.key]) {
    e.preventDefault();
    move(...map[e.key]);
  }
});

// Move player
function move(dr, dc) {
  const [r, c] = player;
  const nr = r + dr;
  const nc = c + dc;
  
  // Check if out of bounds or hit wall
  if (nr < 0 || nc < 0 || nr >= size || nc >= size || maze[nr][nc] === 0) {
    hitCell = [nr >= 0 && nr < size && nc >= 0 && nc < size ? nr : r, 
               nr >= 0 && nr < size && nc >= 0 && nc < size ? nc : c];
    attempts++;
    render();
    updateStatus();
    
    // Reset after 400ms
    setTimeout(() => {
      hitCell = null;
      resetGame();
      render();
      updateStatus();
    }, 400);
    return;
  }
  
  // Valid move
  player = [nr, nc];
  checkCollision();
  render();
  updateStatus();
}

// Check for key collection and home arrival
function checkCollision() {
  // Check if player collected a key
  activeKeys.forEach((k, i) => {
    if (k && player[0] === k[0] && player[1] === k[1]) {
      activeKeys[i] = null;
      keysCollected++;
    }
  });

  // Check if player reached door/home
  if (player[0] === door[0] && player[1] === door[1]) {
    if (keysCollected === 2) {
      gameWon = true;
      gameActive = false;
      clearInterval(timerInterval);
      
      const minutes = Math.floor((240 - timeLeft) / 60);
      const seconds = (240 - timeLeft) % 60;
      const timeUsed = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      document.getElementById("winMessage").innerHTML = 
        `<div class="win-message">üéâ Victory! You completed the ${size}√ó${size} maze in ${timeUsed} (${attempts} attempts)!</div>`;
      
      // Show solution button on win
      document.getElementById("solutionBtn").style.display = "inline-block";
      document.getElementById("solutionBtn").textContent = "View Solution Path";
      
      // Auto-restart after 4 seconds
      setTimeout(() => {
        if (!showingSolution) {
          startGame(size);
        }
      }, 4000);
    } else {
      // Reached home without all keys - restart
      attempts++;
      setTimeout(() => {
        resetGame();
        render();
        updateStatus();
      }, 300);
    }
  }
}

// Render the maze
function render() {
  let html = "<table>";
  for (let r = 0; r < size; r++) {
    html += "<tr>";
    for (let c = 0; c < size; c++) {
      let cls = [];
      
      // Show solution path if enabled
      if (showingSolution) {
        if (solutionPath.some(([pr, pc]) => pr === r && pc === c)) {
          cls.push("solution-path");
        }
        // Highlight key positions in solution
        if (keys.some(k => k && k[0] === r && k[1] === c)) {
          cls.push("solution-key");
        }
      }
      
      // Show player
      if (player[0] === r && player[1] === c) {
        if (gameWon && r === door[0] && c === door[1]) {
          cls.push("player-home");
        } else {
          cls.push("player");
        }
      }
      
      // Show active keys (not collected yet)
      if (!showingSolution) {
        activeKeys.forEach(k => {
          if (k && k[0] === r && k[1] === c) {
            cls.push("key");
          }
        });
      }
      
      // Show door
      if (r === door[0] && c === door[1] && !cls.includes("player-home")) {
        if (keysCollected === 2 || showingSolution) {
          cls.push("home");
        } else {
          cls.push("door");
        }
      }
      
      // Show hit cell
      if (hitCell && hitCell[0] === r && hitCell[1] === c) {
        cls = ["hit"];
      }
      
      html += `<td class="${cls.join(" ")}"></td>`;
    }
    html += "</tr>";
  }
  html += "</table>";
  document.getElementById("maze").innerHTML = html;
}

// Update status display
function updateStatus() {
  document.getElementById("keyCount").textContent = keysCollected;
  document.getElementById("attempts").textContent = attempts;
  updateTimerDisplay();
}

// Timer functions
function startTimer() {
  timerInterval = setInterval(() => {
    if (!gameActive) {
      clearInterval(timerInterval);
      return;
    }
    
    timeLeft--;
    updateTimerDisplay();
    
    if (timeLeft <= 0) {
      gameOver();
    }
  }, 1000);
}

function updateTimerDisplay() {
  const minutes = Math.floor(timeLeft / 60);
  const seconds = timeLeft % 60;
  const timerDisplay = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  const timerElement = document.getElementById("timer");
  
  timerElement.textContent = timerDisplay;
  
  // Remove all timer classes
  timerElement.classList.remove('timer-warning', 'timer-critical');
  
  // Add warning/critical classes based on time
  if (timeLeft <= 30) {
    timerElement.classList.add('timer-critical');
  } else if (timeLeft <= 60) {
    timerElement.classList.add('timer-warning');
  }
  
  // Show solution button when time runs out
  if (timeLeft <= 0) {
    document.getElementById("solutionBtn").style.display = "inline-block";
  }
}

function gameOver() {
  gameActive = false;
  gameWon = false;
  clearInterval(timerInterval);
  
  document.getElementById("winMessage").innerHTML = 
    `<div class="lose-message">‚è∞ TIME'S UP! You're out! Try again?</div>`;
  
  // Show solution button
  document.getElementById("solutionBtn").style.display = "inline-block";
  
  // Auto-restart after 3 seconds
  setTimeout(() => {
    if (!showingSolution) {
      document.getElementById("winMessage").innerHTML = "";
      startGame(size);
    }
  }, 3000);
}

// Show solution path
function showSolution() {
  showingSolution = true;
  solutionPath = [];
  
  // Find path from start to key1 to key2 to home using BFS
  const findPath = (start, end) => {
    const queue = [[start, [start]]];
    const visited = new Set([`${start[0]},${start[1]}`]);
    
    while (queue.length > 0) {
      const [[r, c], path] = queue.shift();
      
      if (r === end[0] && c === end[1]) {
        return path;
      }
      
      for (const [dr, dc] of DIRS) {
        const nr = r + dr;
        const nc = c + dc;
        const key = `${nr},${nc}`;
        
        if (nr >= 0 && nr < size && nc >= 0 && nc < size && 
            maze[nr][nc] === 1 && !visited.has(key)) {
          visited.add(key);
          queue.push([[nr, nc], [...path, [nr, nc]]]);
        }
      }
    }
    return [];
  };
  
  // Path: Start -> Key1 -> Key2 -> Home
  const pathToKey1 = findPath([0, 0], keys[0]);
  const pathToKey2 = findPath(keys[0], keys[1]);
  const pathToHome = findPath(keys[1], door);
  
  // Combine all paths (remove duplicates at junctions)
  solutionPath = [
    ...pathToKey1,
    ...pathToKey2.slice(1), // Skip first element (same as last of pathToKey1)
    ...pathToHome.slice(1)  // Skip first element (same as last of pathToKey2)
  ];
  
  render();
  
  const pathLength = solutionPath.length;
  document.getElementById("winMessage").innerHTML = 
    `<div class="solution-text">
      ‚ú® <strong>SOLUTION REVEALED</strong> ‚ú®<br>
      üü¢ Green path = Correct route (${pathLength} steps)<br>
      üü° Yellow highlight = Key locations<br>
      Follow: Start ‚Üí üîë Key 1 ‚Üí üîë Key 2 ‚Üí üè† Home
    </div>`;
}

// Start with medium difficulty
startGame(6);
</script>
</body>
</html>